---
title: 3.3 노드 내장 객체 알아보기
layout: single
author_profile: true
read_time: true
comments: true
categories:
  - Node.js
toc: true
toc_sticky: true
toc_label: 목차
description: Node.js theory
tags: [Node.js, theory]
meta_keywords: node js,node.js, node개념, node.js개념, 프로미스
---

# 3.3 노드 내장 객체 알아보기

노드에서는 기본적인 내장 객체와 내장 모듈을 제공한다.

따로 설치하지 않아도 가능하고, 브라우저의 window 객체와 유사하다.

## 3.3.1) global

global 객체는 전역 객체로써 브라우저의 window와 비슷하다.

전역 객체이므로 모든 파일에서 접근할 수 있다. 또한, [window.open](http://window.open) 메서드를 window를 생략하고 open으로 호출 할 수 있는 것 처럼 global도 생략 가능하다.

이전 절에서 사용했던 require 함수도 global.require에서 global이 생략된 것이다. 콘솔객체도 원래 형태는global.console이다.

- 노드의 window, document 객체

노드에 DOM이나 BOM이 없으므로 window와 document 객체를 사용할 수 없다.

언제 사용하는가?

파일 간에 간단한 데이터를 공유할 때 사용하기도 한다.

```jsx
/* a.js */
module.exports = () => global.message; // global 객체의 message를 반환
```

```jsx
/* b.js */
const A = require(./a);

global.message = '안녕하세요'; // 내용을 b에서 등록

console.log(A());

=> 안녕하세요
```

- global 객체의 남용

global 객체의 속성에 값을 대입하여 파일 간에 데이터를 공유할 수 있지만, 남용할 우려가 있다.

프로그램의 규모가 커질 수록 어떤 파일에서 global 객체에 값을 대입했는지 찾기 힘들어져 유지 보수에 어려움을 겪게 된다. 다른 파일의 값을 사용하고 싶다면 모듈 형식으로 만들어 명시적으로 사용하는 것이 좋다.

## 3.3.2) console

현재까지 사용했던 console도 노드에서는 window 대신 global 객체 안에 들어 있으며, 

브라우저에서의 console과 거의 비슷하다. console 객체는 내용 확인을 위해 사용된다.

- console.time('시간 측정 시 표출 문구'), console.timeEnd('시간 측정 시 표출 문구') # 시간 측정 시

```jsx
console.time('check time'); // label이 같아야함
for(let i = 0; i<100000; ++i);
console.timeEnd('check time'); // label이 같아야함
```

- console.error('에러 내용') # 에러내용 표출

```jsx
try{
	/* do something */
}catch(e){
	console.error(e);
}
```

- console.table(collection) # 콜랙션형태를 테이블형태로 보기

```jsx
const users = [
	{id:1, name: 'a'},
	{id:2, name: 'b'},
	{id:3, name: 'c'}
];

console.table(users);

┌─────────┬────┬──────┐
│ (index) │ id │ name │
├─────────┼────┼──────┤
│    0    │ 1  │ 'a'  │
│    1    │ 2  │ 'b'  │
│    2    │ 3  │ 'c'  │
└─────────┴────┴──────┘
```

- console.dir(객체, 옵션) # 객체를 정돈된 형태로 보기

```jsx
const userInfo = {
	name: '유성민',
	birth: '1996-01-24',
	job: 'developer'
}

console.log(userInfo);

{ name: '유성민', birth: '1996-01-24', job: 'developer' }
```

## 3.3.3) 타이머

타이머 기능을 제공하는 함수로는 setTimeout, setInterval, setImmediate가 있고, window대신 global에 들어있다.

- setTimeout(calback, msec);
  - 주어진 밀리초(1000분의 1초) 이후에 콜백 함수를 실행합니다.
- setInterval(callback, msec);
  - 주어진 밀리초마다 콜백 함수를 반복 실행
- setImmediate(callback);
  - 콜백 함수를 즉시 실행

이 타이머 함수들은 모두 아이디를 반환하는데, 이것을 이용항 타이머를 취소할 수 있다.

- clearTimeout(id);
  - setTimeout을 취소
- clearInterval(id);
  - setInterval을 취소
- clearImmediate(id);
  - setImmediate를 취소

```jsx
const timeOut = setTimeout(() => {
  console.log("1초 뒤에 실행");
}, 1000);

console.log(timeOut);

clearTimeout(timeOut);
```

- setImmediate(callback)과 setTimeot(callback, 0)의 차이

setImmediate와 setTimeout에 담긴 콜백함수는 이벤트 루프를 거친 뒤 즉시 실행되는데,  특수한 경우setImmediate는 setTimeout보다 먼저 실행된다. 이를 테면 파일 시스템 접근, 네트워킹 IO 작업의 콜백 함수 안에서 타이머를 호출하는 경우이다. 그러나 항상 setImmediate가 setTimeout보다 선행되는 것은 아니다. 혼란의 여지가 없도록 바로 호출해야 하는 경우라면 setImmediate를 사용하자

## 3.3.4) __filename, __dirname

모듈 시스템으로 복잡한 노드 위에서 돌아가는 프로그램은 때때로 현재 파일 경로나 파일명을 알아야하는데, 노드는 __filename과 __dirname이라는 키워드로 경로 정보를 제공한다. 파일에 __filename과 __dirname을 넣어두면 실행 시 현 파일명과 현 파일 경로로 바뀐다. 즉, 다이나믹하게 변경되는 변수라는 것이다.

```jsx
/* /usr/workspace/front/path.js 에서 실행 */

console.log(__filename);
console.log(__dirname);

/usr/workspace/front/path.js
/usr/workspace/front
```

```jsx
/* /usr/workspace/backend/path.js 에서 실행 */console.log(__filename);console.log(__dirname);/usr/workspace/backend/path.js/usr/workspace/backend
```

경로 separator 문제가 생기는 경우가 빈번하여 주로 path 모듈과 함께 사용한다.

## 3.3.5) module, exports, require

모듈을 만들 때 module.exports를 사용했지만, module객체 말고도 exports 객체로도 모듈을 생성할 수 있다.

```jsx
/* var.js */exports.a = 1;exports.b = 2;
```

```jsx
/* func.js */const vars = require('./var');console.log(vars.a);=> 1
```

module.exports로 일괄 대입하는 대신, 각 변수를 exports에 넣은 것이다. 

객체 초기화할 때랑 같은 경우라 보면 된다.

 

```jsx
const o = {	a: 1,	b: 2}== const o = {};o.a = 1;o.b = 2;
```

이것이 동작하는 이유는 module.exports와 exports가 같은 객체를 참조하기 때문이다.

즉, module.exports === exports ⇒ true이다. 

![3.3.1]({{ site.url }}{{ site.baseurl }}/assets/images/node.js/3.3.1.jpg)

❗주의

exports 객체를 사용할 때는 module.exports와의 참조 관계가 깨지지 않도록 주의해야 한다.

module.exports에는 어떤 값이든 대입해도 되지만, exports에는 반드시 객체처럼 키와 밸류를 대입해야 한다.

exports에 다른 값을 대입하면 객체의 참조관계가 끊겨 더이상 모듈로 기능하지 않는다. 이를 테면 exports foo = addTwoNum 이런식으로 함수를 대입하면 더이상 모듈로 못쓴다는 얘기다.

export와 module.exports에는 레퍼런스가 있으므로 한 모듈에 exports 객체와 module.exports를 동시에 사용하지 않는 것이 좋다.

❗this

node에서 최상위 scope의 this는 module.exports를 가리키고 함수 선언 문 내부의 this는 global 객체를 가리킨다.

- require

require은 모듈을 불러오는 역할을 한다. require는 함수이고, 함수는 객체이므로 require는 객체로서 몇 가지 속성을 갖는다. 그 중에서 cache와 main이 있다.

require.cache 객체에는 파일 이름이 key, 각 파일의 모듈 객체가 value로 들어있다. 한 번 require한 파일은 require.cache에 저장되므로, 재사용시에, cache을 이용하여 재사용 한다.

속성들을 자세히 보면, module.export(exports), loaded, parent, children 모듈 관계를 찾아볼 수 있다.

require.main은 노드 실행 시 첫 모듈을 가리킨다. 즉 실행한 파일이다. 현재 파일이 첫 모듈인지 알아보려면 `require.main === module`을 해보면 되겠다. 첫 모듈의 파일이름은 `require.main.filename` 으로 확인 해보자.

- 순환 참조

모듈을 사용할 때 주의점으로 순환 참조가 있다. 순환 참조는 서로 다른 두 모듈이 서로를 require하여 참조하는 경우를 일컫는다.

```jsx
// module1.jsconst module2 = require('./module2');console.log('require module 2', module2);module.exports = () => {	console.log('module2', module2);}
```

```jsx
// module2.jsconst module1 = require('./module1');console.log('require module 1', module1);module.exports = () => {	console.log('module1', module1);}
```

```jsx
const module1 = require('./module1');const module2 = require('./module2');module1();module2();
```

코드의 실행 순서에 따라 module1이 먼저 호출되는데, module1이 빈 객체로 리턴된다. 이렇게 순환 참조가 있을 경우는 제일 나중에 실행된 순환 참조 사이클에 있는 모듈만 제대로 나오고, 그 이전 모듈들은 빈 객체로 리턴된다. 주의할 점이라는 것은 에러가 발생하지않고, 빈 객체로 리턴된다는 것이다.

## 3.3.6) process

process 객체는 현재 실행되고 있는 노드 프로세스에 대한 정보를 담고있다. 그래서 pid, uptime, platform 등등 다양한 시스템 관련 정보를 참조할 수 있는데, 이 정보들은 일반적으로 운영체제난 실행 환경별로 다른 동작을 시키고 싶을 때 사용한다. process.env, process.nextTick, process.exit()이 특히 중요하다.

(1) process.env

시스템의 환경 변수인데, 이것은 노드에 직접적 영향을 미치기도 한다. 대표적인 것으로 UV_TREADPOOL_SIZE, NODE_OPTIONS가 있다. 첫 번째로 NODE_OPTIONS는 노드를 실행할 때 옵션들을 입력받는 환경 변수이다. —max-old-space-size=4096는 노드의 메모리의 최대 사용량을 4GB로 설정하는 것이다.  UV_TREADPOOL_SIZE의 경우는 노드에서 기본적으로 사용하는 스레드풀의 스레드 개수를 조절할 수 있게 한다.

시스템의 환경 변수 외에도 임의로 환경 변수를 저장할 수 있다. process.env는 서비스의 중요한 키들을 저장하는 공간으로도 사용된다. 서버나 데이터베이스의 비밀번호와 각종 API KEY들은 코드와 분리 되있어야 하는데, 혹여나 해킹으로 인해 코드가 유출될 수 있기 때문이다. 

```jsx
cosnt kakaoAPIKey = process.env.KAKAO_API_KEY
```

이런식으로 사용한다.  env에 값을 넣는 방법은 os마다 다르나 한 번에 모든 운영체제에 동일하게 넣을 수 있는 방법이 있는데 이것은 dotenv를 이용하는 것이다.

(2) process.nextTick 콜백

이것은 이벤트 루프의 스케줄링 상에서 최우선 순위를 가지게 만든다는 것이다.

```jsx
setImmediate(() => console.log('즉시'));process.nextTick(() => console.log('next tick'));setTimeout(() => console.log('timeout 0'), 0);Promise.resolve().then(() => console.log('promise'));
```

```jsx
실행 순서1. next tick2. promise3. timeout4. immediate 
```

resolve된 프로미스도 nextTick처럼 다른 콜백들보다 우선권을 갖는다. 그래서 nextTick, resolved promise를 마이크로 태스크라고 따로 구분짓는다.

우선권의 이점때문에 비동기 처리를 할 때 setImmediate보다 process.nextTick을 더 선호하는 개발자들도 있지만, 이로 인해 우선순위가 낮은 콜백들의 starvation이 발생할 수 있으니 주의하자.

![3.3.2]({{ site.url }}{{ site.baseurl }}/assets/images/node.js/3.3.2.png)

(3) process.exit(종료 코드)

실행 중인 노드 프로세스를 종료하는 역할을 한다. 서버 환경에서 이 함수를 사용하면 서버가 아예 멈춰버리므로 주의해서 사용해야 한다. 일반적으로 서버와 독립적인 프로그램에서 수동으로 노드를 종료시키기 위해 사용한다.

종료 코드로는 0과 1이 있는데 0은 정상 종료, 1은 에러로 인한 비정상 종료를 의미하기에 상황에 따라 적절한 코드를 주면 되겠다.

**(Node.js 교과서 개정 2판 - 길벗, 2021)을 학습하고 개인 학습용으로 정리한 내용입니다.**